# Backtracking and Recursion is one of the most fundemental concepts for algorithims.
# We can implement these techniques on Sudoku to understand how it works as a begginer level at programming.



import numpy as np
board = [
    [7,0,0,4,0,0,1,2,0],
    [6,0,0,0,7,5,0,0,0],
    [0,0,0,6,0,1,0,7,8],
    [0,0,0,0,4,0,2,0,0],
    [0,0,1,0,5,0,9,3,0],
    [9,0,0,0,6,0,0,0,0],
    [0,7,0,3,0,0,0,1,0],
    [1,2,0,0,0,0,4,0,0],
    [0,4,9,2,0,6,0,0,0]]

#this is our board. A 9x9 sudoku map. We can create a new function to make it more understanable.

def mapper(board):
    for i in range(len(board)):
        if i % 3 == 0 and i != 0:
            print("- - - - - - - - - - - - - ")
		# we divide the row by 3.
        for j in range(len(board[0])):
            if j % 3 == 0 and j != 0:
                print(" | ", end="")
		# we divide the columns by 3. (i & j !=0) is for not printing walls before the numbers.
            if j == 8:
                print(board[i][j])
            else:
                print(str(board[i][j]) + " ", end="")



# now we have 3 parameters,
# y,x and n
# step 1)
# first check the row (y). after that, column(x) and lastly the 3x3 square (y,x)

def possible(y,x,n):
    global board
    for i in range (0,9):
        if board[y][i] == n:
            return False
    for i in range(0,9):
        if board[i][x] ==  n:
            return False
    x0 =(x//3)*3
    y0 =(y//3)*3
	#  the reason we divide and multiply by 3 can been seen dumb. But it is for understanding what "3x3 boxes" we are in.
    for i in range(0,3):
        for j in range(0,3):
            if board[y0+i][x0+j] == n:
                return False
    return True

def solve():
    global board
    for y in range(9):
        for x in range(9):
            if board[y][x] == 0:
                for n in range (1,10):
                    if possible(y,x,n):
			                  #  from here we checked if it is possible to put a value to our square. and if possible, putting a value to it
                        board[y][x] = n
			                  #  now we have 1 value. lets call solve again for the next one.
                       	solve()
			                  #  But what if from here we made a bad choise? if the answer gives a dead end ,we should take the value back and give 0 again.
                        #  This is Bactracking.If the solution gives a dead end it deletes the value at 1 step back and tries that one again with different value
                        #  If these new solutions gives another dead end process continues from 1 step back again.This concept is extremely usefull at decition algorityms.
                        board[y][x]= 0
			                  #  after triying every solution and not working, we have to return the last checkpoint.
                return
    print(np.matrix(board))
    # there can be more than 1 possible solutions of sudoku game. It is based on how many empty spaces tehre are. So if we want to see more than 1 solutions, we can just call an intup and let the loop run again
    input("press enter to see more")     


solve()
print("this is all")
